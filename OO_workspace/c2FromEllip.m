function [ellip,std_e] = c2FromEllip(t2_array,ellipticityStruct)
% [c2, c2_std] = c2FromEllip(t2_array,ellipticityStruct)
%
% This function requires an input of an array of population times (t2), and
% an ellipticity structure similar to the one generated by 'fitEllip.m.'
% Specifically, it is important that (1) you named the widths sD
% (diagonal) and sA (antidiagonal) in your function, AND that they will be
% the 4th and 5th variables (this is important for getting the correct
% confidence intervals to find their standard deviations). Your ellipticity
% structure should be in the same order as your t2 array (sorted by t2).
% 
% The returns of this function will be arrays of ellipticities (~two-point
% correlations) and their standard deviations, for each population time.
%
% TODO: Allow arbitrary ordering of variables (i.e., automatically find the
% correct elements to take the confidence interval of by looking at their
% names.

ellip = zeros(size(t2_array));
std_e = zeros(size(t2_array));
for ii = 1:length(ellipticityStruct)
  dummy = confint(ellipticityStruct(ii).fitresult);
  err_sD = dummy(:,4);
  err_sA = dummy(:,5);
  std_sD = (err_sD(2) - err_sD(1))/2; %std of sd
  std_sA = (err_sA(2) - err_sA(1))/2; %std of sa
  sD = ellipticityStruct(ii).fitresult.sD;
  sA = ellipticityStruct(ii).fitresult.sA;
  de_sD = (4*sD*sA^2)/(sD^2+sA^2)^2; %derivatives for sD
  de_sA = -(4*sD^2*sA)/(sD^2+sA^2)^2; %derivatives for sA
  ellip(ii) = (sD.^2-sA.^2)./(sD.^2+sA.^2);
  std_e(ii) = (de_sD.^2*std_sD.^2 + de_sA.^2*std_sA.^2)^0.5;
end